"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileMatcher = undefined;
exports.deprecatedUserIgnoreFilter = deprecatedUserIgnoreFilter;

var _path = _interopRequireWildcard(require("path"));

var _filter;

function _load_filter() {
    return _filter = require("./util/filter");
}

var _minimatch;

function _load_minimatch() {
    return _minimatch = require("minimatch");
}

var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class FileMatcher {
    constructor(from, to, options, patterns) {
        this.options = options;
        this.from = this.expandPattern(from);
        this.to = this.expandPattern(to);
        this.patterns = (0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(patterns);
    }
    addPattern(pattern) {
        this.patterns.push(pattern);
    }
    addAllPattern() {
        // must be first, see minimatchAll implementation
        this.patterns.unshift("**/*");
    }
    isEmpty() {
        return this.patterns.length === 0;
    }
    containsOnlyIgnore() {
        return !this.isEmpty() && this.patterns.find(it => !it.startsWith("!")) == null;
    }
    getParsedPatterns(fromDir) {
        // https://github.com/electron-userland/electron-builder/issues/733
        const minimatchOptions = { dot: true };
        const parsedPatterns = [];
        const pathDifference = fromDir ? _path.relative(fromDir, this.from) : null;
        for (const p of this.patterns) {
            let expandedPattern = this.expandPattern(p);
            if (pathDifference != null) {
                expandedPattern = _path.join(pathDifference, expandedPattern);
            }
            const parsedPattern = new (_minimatch || _load_minimatch()).Minimatch(expandedPattern, minimatchOptions);
            parsedPatterns.push(parsedPattern);
            if (!(0, (_filter || _load_filter()).hasMagic)(parsedPattern)) {
                // https://github.com/electron-userland/electron-builder/issues/545
                // add **/*
                parsedPatterns.push(new (_minimatch || _load_minimatch()).Minimatch(`${expandedPattern}/**/*`, minimatchOptions));
            }
        }
        return parsedPatterns;
    }
    createFilter(ignoreFiles, rawFilter, excludePatterns) {
        return (0, (_filter || _load_filter()).createFilter)(this.from, this.getParsedPatterns(), ignoreFiles, rawFilter, excludePatterns);
    }
    expandPattern(pattern) {
        return pattern.replace(/\$\{arch}/g, this.options.arch).replace(/\$\{os}/g, this.options.os).replace(/\$\{\/\*}/g, "{,/**/*}");
    }
}
exports.FileMatcher = FileMatcher;
function deprecatedUserIgnoreFilter(ignore, appDir) {
    let ignoreFunc;
    if (typeof ignore === "function") {
        ignoreFunc = function (file) {
            return !ignore(file);
        };
    } else {
        if (!Array.isArray(ignore)) {
            ignore = [ignore];
        }
        ignoreFunc = function (file) {
            for (const i of ignore) {
                if (file.match(i)) {
                    return false;
                }
            }
            return true;
        };
    }
    return function filter(file) {
        let name = file.split(_path.resolve(appDir))[1];
        if (_path.sep === "\\") {
            // convert slashes so unix-format ignores work
            name = name.replace(/\\/g, "/");
        }
        return ignoreFunc(name);
    };
}
//# sourceMappingURL=fileMatcher.js.map