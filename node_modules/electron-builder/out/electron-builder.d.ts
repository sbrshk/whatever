declare module "electron-builder/out/asarUtil" {
  import { Filter } from "electron-builder-util/out/fs"
  import { AsarOptions } from "electron-builder/out/metadata"

  export function createAsarArchive(src: string, resourcesPath: string, options: AsarOptions, filter: Filter, unpackPattern: Filter | null): Promise<any>

  export function checkFileInArchive(asarFile: string, relativeFile: string, messagePrefix: string): Promise<void>
}

declare module "electron-builder/out/packager/dirPackager" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export function unpackElectron(packager: PlatformPackager<any>, out: string, platform: string, arch: string, electronVersion: string): Promise<void>
}

declare module "electron-builder/out/util/filter" {
  import { Minimatch } from "minimatch"
  import { Filter } from "electron-builder-util/out/fs"

  export function hasMagic(pattern: Minimatch): boolean

  export function createFilter(src: string, patterns: Array<Minimatch>, ignoreFiles?: Set<string>, rawFilter?: (file: string) => boolean, excludePatterns?: Array<Minimatch> | null): Filter
}

declare module "electron-builder/out/fileMatcher" {
  import { Minimatch } from "minimatch"
  import { Filter } from "electron-builder-util/out/fs"

  export interface FilePattern {
    from?: string
    to?: string
    filter?: Array<string> | string
  }

  export interface FileMatchOptions {
    arch: string
    os: string
  }

  export class FileMatcher {
    private options
    readonly from: string
    readonly to: string
    readonly patterns: Array<string>
    constructor(from: string, to: string, options: FileMatchOptions, patterns?: Array<string> | string | n)
    addPattern(pattern: string): void
    addAllPattern(): void
    isEmpty(): boolean
    containsOnlyIgnore(): boolean
    getParsedPatterns(fromDir?: string): Array<Minimatch>
    createFilter(ignoreFiles?: Set<string>, rawFilter?: (file: string) => boolean, excludePatterns?: Array<Minimatch> | n): Filter
    private expandPattern(pattern)
  }

  export function deprecatedUserIgnoreFilter(ignore: Array<RegExp> | ((file: string) => boolean), appDir: string): (file: string) => any
}

declare module "electron-builder/out/readInstalled" {
  
  export interface Dependency {
    name: string
    path: string
    extraneous: boolean
    optional: boolean
    dependencies: {
      [name: string]: Dependency
    }
  }

  export function readInstalled(folder: string): Promise<Map<string, Dependency>>
}

declare module "electron-builder/out/packagerApi" {
  /// <reference types="node" />
  import { Platform, Arch, Target } from "electron-builder-core"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Metadata, Config, AfterPackContext } from "electron-builder/out/metadata"
  import { PublishConfiguration } from "electron-builder-http/out/publishOptions"
  import { TmpDir } from "electron-builder-util/out/tmp"
  import { AppInfo } from "electron-builder/out/appInfo"

  export interface PackagerOptions {
    targets?: Map<Platform, Map<Arch, string[]>>
    projectDir?: string | null
    cscLink?: string | null
    cscKeyPassword?: string | null
    cscInstallerLink?: string | null
    cscInstallerKeyPassword?: string | null
    platformPackagerFactory?: ((info: BuildInfo, platform: Platform, cleanupTasks: Array<() => Promise<any>>) => PlatformPackager<any>) | null
    /**
     * @deprecated Use {@link PackagerOptions#config} instead.
     */
    readonly devMetadata?: Metadata
    readonly config?: Config
    /**
     * The same as [application package.json](https://github.com/electron-userland/electron-builder/wiki/Options#AppMetadata).
     *
     * Application `package.json` will be still read, but options specified in this object will override.
     */
    readonly appMetadata?: Metadata
    readonly effectiveOptionComputed?: (options: any) => Promise<boolean>
    readonly extraMetadata?: any
    readonly prepackaged?: string
  }

  export interface BuildInfo {
    options: PackagerOptions
    metadata: Metadata
    config: Config
    projectDir: string
    appDir: string
    electronVersion: string
    isTwoPackageJsonProjectLayoutUsed: boolean
    appInfo: AppInfo
    readonly tempDirManager: TmpDir
    repositoryInfo: Promise<SourceRepositoryInfo | null>
    dispatchArtifactCreated(event: ArtifactCreated): void
    afterPack(context: AfterPackContext): Promise<void>
  }

  export interface ArtifactCreated {
    readonly packager: PlatformPackager<any>
    readonly target: Target | null
    readonly file?: string
    readonly data?: Buffer
    readonly artifactName?: string
    readonly publishConfig?: PublishConfiguration
  }

  export interface SourceRepositoryInfo {
    type: string
    domain: string
    user: string
    project: string
  }
}

declare module "electron-builder/out/platformPackager" {
  import { PlatformSpecificBuildOptions, FileAssociation, Config } from "electron-builder/out/metadata"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { Arch, Target, Platform } from "electron-builder-core"
  import { PackagerOptions, BuildInfo } from "electron-builder/out/packagerApi"

  export abstract class PlatformPackager<DC extends PlatformSpecificBuildOptions> {
    readonly info: BuildInfo
    readonly packagerOptions: PackagerOptions
    readonly projectDir: string
    readonly buildResourcesDir: string
    readonly config: Config
    readonly platformSpecificBuildOptions: DC
    readonly resourceList: Promise<Array<string>>
    readonly abstract platform: Platform
    readonly appInfo: AppInfo
    constructor(info: BuildInfo)
    readonly abstract defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    private static normalizePlatformSpecificBuildOptions(options)
    abstract createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    protected getCscPassword(): string
    protected doGetCscPassword(): any
    readonly relativeBuildResourcesDirname: string
    protected computeAppOutDir(outDir: string, arch: Arch): string
    dispatchArtifactCreated(file: string, target: Target | null, artifactName?: string): void
    pack(outDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): Promise<any>
    protected packageInDistributableFormat(appOutDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): void
    private getExtraFileMatchers(isResources, appOutDir, fileMatchOptions, customBuildOptions)
    protected doPack(outDir: string, appOutDir: string, platformName: string, arch: Arch, platformSpecificBuildOptions: DC): Promise<void>
    protected postInitApp(executableFile: string): Promise<any>
    getIconPath(): Promise<string | null>
    private computeAsarOptions(customBuildOptions)
    private doCopyExtraFiles(patterns)
    private getFileMatchers(name, defaultSrc, defaultDest, allowAdvancedMatching, fileMatchOptions, customBuildOptions)
    getResourcesDir(appOutDir: string): string
    getMacOsResourcesDir(appOutDir: string): string
    private checkFileInPackage(resourcesDir, file, messagePrefix, isAsar)
    private sanityCheckPackage(appOutDir, isAsar)
    generateName(ext: string | null, arch: Arch, deployment: boolean, classifier?: string | null): string
    generateName2(ext: string | null, classifier: string | n, deployment: boolean): string
    getDefaultIcon(ext: string): Promise<string | null>
    getTempFile(suffix: string): Promise<string>
    readonly fileAssociations: Array<FileAssociation>
    getResource(custom: string | n, ...names: Array<string>): Promise<string | null>
  }

  export function normalizeExt(ext: string): string
}

declare module "electron-builder/out/options/macOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  export type MacOsTargetName = "default" | "dmg" | "mas" | "pkg" | "7z" | "zip" | "tar.xz" | "tar.lz" | "tar.gz" | "tar.bz2" | "dir"

  export interface MacOptions extends PlatformSpecificBuildOptions {
    readonly category?: string | null
    readonly target?: Array<MacOsTargetName> | null
    readonly identity?: string | null
    readonly icon?: string | null
    readonly entitlements?: string | null
    readonly entitlementsInherit?: string | null
    readonly bundleVersion?: string | null
    readonly helperBundleId?: string | null
  }

  export interface DmgOptions {
    readonly background?: string | null
    readonly backgroundColor?: string | null
    readonly icon?: string | null
    readonly iconSize?: number | null
    readonly iconTextSize?: number | null
    readonly title?: string | null
    readonly contents?: Array<DmgContent>
    readonly format?: string
    window?: DmgWindow
  }

  export interface DmgWindow {
    x?: number
    y?: number
    /**
     * The width. Defaults to background image width or 540.
     */
    width?: number
    /**
     * The height. Defaults to background image height or 380.
     */
    height?: number
  }

  export interface DmgContent {
    x: number
    y: number
    type?: "link" | "file"
    name?: string
    path?: string
  }

  export interface MasBuildOptions extends MacOptions {
    readonly entitlements?: string | null
    readonly entitlementsInherit?: string | null
  }
}

declare module "electron-builder/out/options/winOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface WinBuildOptions extends PlatformSpecificBuildOptions {
    readonly target?: Array<string> | null
    readonly signingHashAlgorithms?: Array<string> | null
    readonly icon?: string | null
    readonly legalTrademarks?: string | null
    readonly certificateFile?: string
    readonly certificatePassword?: string
    readonly certificateSubjectName?: string
    readonly rfc3161TimeStampServer?: string
    readonly timeStampServer?: string
  }

  export interface NsisOptions {
    readonly oneClick?: boolean
    readonly perMachine?: boolean
    readonly allowElevation?: boolean
    readonly allowToChangeInstallationDirectory?: boolean
    readonly runAfterFinish?: boolean
    readonly guid?: string | null
    readonly installerIcon?: string | null
    readonly installerHeader?: string | null
    readonly installerHeaderIcon?: string | null
    readonly include?: string | null
    readonly script?: string | null
    readonly license?: string | null
    readonly language?: string | null
    readonly warningsAsErrors?: boolean
    readonly menuCategory?: boolean | string
  }

  export interface SquirrelWindowsOptions extends WinBuildOptions {
    readonly iconUrl?: string | null
    readonly loadingGif?: string | null
    readonly msi?: boolean
    readonly remoteReleases?: string | boolean | null
    readonly remoteToken?: string | null
    readonly useAppIdAsId?: boolean
  }

  export interface AppXOptions {
    readonly backgroundColor?: string | null
    readonly makeappxArgs?: Array<string> | null
    readonly publisher?: string | null
    readonly displayName?: string | null
    readonly publisherDisplayName?: string | null
    readonly identityName?: string | null
  }
}

declare module "electron-builder/out/options/linuxOptions" {
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface LinuxBuildOptions extends PlatformSpecificBuildOptions {
    readonly category?: string | null
    readonly packageCategory?: string | null
    readonly description?: string | null
    readonly target?: Array<string> | null
    readonly synopsis?: string | null
    readonly maintainer?: string | null
    readonly vendor?: string | null
    readonly fpm?: Array<string> | null
    /**
     The [Desktop file](https://developer.gnome.org/integration-guide/stable/desktop-files.html.en) entries (name to value).
     */
    readonly desktop?: {
      [key: string]: string
    } | null
    readonly afterInstall?: string | null
    readonly afterRemove?: string | null
    readonly compression?: string | null
    readonly depends?: string[] | null
    readonly executableName?: string | null
  }

  export interface SnapOptions extends LinuxBuildOptions {
    confinement?: "devmode" | "strict" | null
    summary?: string | null
    grade?: "devel" | "stable" | null
    assumes?: Array<string> | null
    stagePackages?: Array<string> | null
    ubuntuAppPlatformContent?: string | null
  }

  export interface AppImageOptions extends LinuxBuildOptions {
    includeRequiredLib?: boolean | null
  }
}

declare module "electron-builder/out/metadata" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { MacOptions, DmgOptions, MasBuildOptions } from "electron-builder/out/options/macOptions"
  import { Publish } from "electron-builder-http/out/publishOptions"
  import { WinBuildOptions, NsisOptions, SquirrelWindowsOptions, AppXOptions } from "electron-builder/out/options/winOptions"
  import { LinuxBuildOptions, SnapOptions } from "electron-builder/out/options/linuxOptions"
  import { Platform } from "electron-builder-core"

  export interface AsarOptions {
    dot?: boolean
    smartUnpack?: boolean
    ordering?: string | null
    extraMetadata?: any | null
  }

  export interface Metadata {
    readonly repository?: string | RepositoryInfo | null
    readonly dependencies?: {
      [key: string]: string
    }
    readonly version?: string
    readonly name?: string
    readonly productName?: string | null
    readonly description?: string
    readonly main?: string | null
    readonly author?: AuthorMetadata
    readonly homepage?: string | null
    readonly license?: string | null
    readonly build?: Config
  }

  export interface RepositoryInfo {
    readonly url: string
  }

  export interface AuthorMetadata {
    readonly name: string
    readonly email?: string
  }
  export type CompressionLevel = "store" | "normal" | "maximum"

  export interface Config extends PlatformSpecificBuildOptions {
    readonly appId?: string | null
    readonly copyright?: string | null
    readonly iconUrl?: string | null
    readonly productName?: string | null
    /**
     A [glob patterns](https://www.npmjs.com/package/glob#glob-primer) relative to the [app directory](#MetadataDirectories-app), which specifies which files to include when copying files to create the package.
  
     See [File Patterns](#multiple-glob-patterns).
     */
    readonly files?: Array<string> | string | null
    readonly extraResources?: Array<string> | string | null
    readonly extraFiles?: Array<string> | string | null
    readonly asar?: AsarOptions | boolean | null
    /**
     A [glob patterns](https://www.npmjs.com/package/glob#glob-primer) relative to the [app directory](#MetadataDirectories-app), which specifies which files to unpack when creating the [asar](http://electron.atom.io/docs/tutorial/application-packaging/) archive.
     */
    readonly asarUnpack?: Array<string> | string | null
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    readonly protocols?: Array<Protocol> | Protocol
    readonly mac?: MacOptions | null
    readonly dmg?: DmgOptions | null
    readonly mas?: MasBuildOptions | null
    readonly win?: WinBuildOptions | null
    readonly nsis?: NsisOptions | null
    readonly squirrelWindows?: SquirrelWindowsOptions | null
    readonly appx?: AppXOptions | null
    readonly linux?: LinuxBuildOptions | null
    readonly deb?: LinuxBuildOptions | null
    readonly snap?: SnapOptions | null
    readonly compression?: CompressionLevel | null
    readonly afterPack?: (context: AfterPackContext) => Promise<any> | null
    readonly beforeBuild?: (context: BeforeBuildContext) => Promise<any> | null
    readonly npmRebuild?: boolean
    readonly npmSkipBuildFromSource?: boolean
    readonly npmArgs?: Array<string> | string | null
    readonly nodeGypRebuild?: boolean
    readonly electronDist?: string
    readonly electronDownload?: any
    readonly icon?: string | null
    readonly publish?: Publish
    readonly forceCodeSigning?: boolean
    readonly directories?: MetadataDirectories | null
    readonly electronVersion?: string | null
  }

  export interface AfterPackContext {
    readonly appOutDir: string
    readonly packager: PlatformPackager<any>
    readonly electronPlatformName: string
  }

  export interface BeforeBuildContext {
    readonly appDir: string
    readonly electronVersion: string
    readonly platform: Platform
    readonly arch: string
  }

  export interface FileAssociation {
    readonly ext: string | Array<string>
    readonly name?: string | null
    readonly description?: string | null
    readonly icon?: string
    readonly role?: string
    readonly isPackage?: boolean
  }

  export interface Protocol {
    readonly name: string
    readonly role?: string
    readonly schemes: Array<string>
  }

  export interface MetadataDirectories {
    readonly buildResources?: string | null
    readonly output?: string | null
    readonly app?: string | null
  }

  export interface PlatformSpecificBuildOptions {
    readonly files?: Array<string> | string | null
    readonly extraFiles?: Array<string> | string | null
    readonly extraResources?: Array<string> | string | null
    readonly asarUnpack?: Array<string> | string | null
    readonly asar?: AsarOptions | boolean | null
    readonly target?: Array<string> | string | null
    readonly icon?: string | null
    readonly fileAssociations?: Array<FileAssociation> | FileAssociation
    readonly publish?: Publish
    readonly forceCodeSigning?: boolean
  }
}

declare module "electron-builder/out/appInfo" {
  import { Metadata } from "electron-builder/out/metadata"
  import { BuildInfo } from "electron-builder/out/packagerApi"

  export class AppInfo {
    metadata: Metadata
    private info
    readonly description: string
    readonly version: string
    readonly buildNumber: string
    readonly buildVersion: string
    readonly productName: string
    readonly productFilename: string
    private readonly config
    constructor(metadata: Metadata, info: BuildInfo, buildVersion?: string | null)
    readonly versionInWeirdWindowsForm: string
    readonly companyName: string
    readonly id: string
    readonly name: string
    readonly copyright: string
    computePackageUrl(): Promise<string | null>
  }
}

declare module "electron-builder/out/codeSign" {
  import { TmpDir } from "electron-builder-util/out/tmp"
  export const appleCertificatePrefixes: string[]
  export type CertType = "Developer ID Application" | "Developer ID Installer" | "3rd Party Mac Developer Application" | "3rd Party Mac Developer Installer" | "Mac Developer"

  export interface CodeSigningInfo {
    keychainName?: string | null
  }

  export function downloadCertificate(urlOrBase64: string, tmpDir: TmpDir): Promise<string>

  export function createKeychain(tmpDir: TmpDir, cscLink: string, cscKeyPassword: string, cscILink?: string | null, cscIKeyPassword?: string | null): Promise<CodeSigningInfo>

  export function sign(path: string, name: string, keychain: string): Promise<any>
  export let findIdentityRawResult: Promise<Array<string>> | null

  export function findIdentity(certType: CertType, qualifier?: string | null, keychain?: string | null): Promise<string | null>
}

declare module "electron-builder/out/windowsCodeSign" {
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"

  export function getSignVendorPath(): Promise<string>

  export interface SignOptions {
    readonly path: string
    readonly cert?: string | null
    readonly subjectName?: string | null
    readonly name?: string | null
    readonly password?: string | null
    readonly site?: string | null
    readonly options: WinBuildOptions
  }

  export function sign(options: SignOptions): Promise<void>
}

declare module "electron-builder/out/targets/appx" {
  import { WinPackager } from "electron-builder/out/winPackager"
  import { Arch } from "electron-builder-core"
  import { Target } from "electron-builder-core"

  export default class AppXTarget extends Target {
    private readonly packager
    private readonly outDir
    private readonly options
    constructor(packager: WinPackager, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
    private writeManifest(templatePath, preAppx, safeName, arch)
  }
}

declare module "electron-builder/out/targets/archive" {
  import { CompressionLevel } from "electron-builder/out/metadata"

  export function tar(compression: CompressionLevel | n, format: string, outFile: string, dirToArchive: string, isMacApp?: boolean): Promise<string>

  export function archive(compression: CompressionLevel | n, format: string, outFile: string, dirToArchive: string, withoutDir?: boolean): Promise<string>
}

declare module "electron-builder/out/targets/nsis" {
  import { WinPackager } from "electron-builder/out/winPackager"
  import BluebirdPromise from "bluebird-lst-c"
  import { Target, Arch } from "electron-builder-core"

  export default class NsisTarget extends Target {
    private packager
    private outDir
    private readonly options
    private archs
    private readonly nsisTemplatesDir
    constructor(packager: WinPackager, outDir: string)
    build(appOutDir: string, arch: Arch): BluebirdPromise<null>
    private doBuild(appOutDir, arch)
    finishBuild(): Promise<any>
    private buildInstaller()
    private executeMakensis(defines, commands, isInstaller, originalScript)
  }
}

declare module "electron-builder/out/targets/ArchiveTarget" {
  import { Target, Arch } from "electron-builder-core"
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export class ArchiveTarget extends Target {
    readonly outDir: string
    private readonly packager
    constructor(name: string, outDir: string, packager: PlatformPackager<any>)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/targetFactory" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Arch, Target } from "electron-builder-core"
  export const DEFAULT_TARGET = "default"
  export const DIR_TARGET = "dir"

  export function createTargets(nameToTarget: Map<String, Target>, rawList: Array<string> | n, outDir: string, packager: PlatformPackager<any>, cleanupTasks: Array<() => Promise<any>>): Array<Target>

  export function createCommonTarget(target: string, outDir: string, packager: PlatformPackager<any>): Target

  export class NoOpTarget extends Target {
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/winPackager" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Platform, Target } from "electron-builder-core"
  import { SignOptions } from "electron-builder/out/windowsCodeSign"
  import { WinBuildOptions } from "electron-builder/out/options/winOptions"
  import { BuildInfo } from "electron-builder/out/packagerApi"

  export interface FileCodeSigningInfo {
    readonly file?: string | null
    readonly password?: string | null
    readonly subjectName?: string | null
  }

  export class WinPackager extends PlatformPackager<WinBuildOptions> {
    readonly cscInfo: Promise<FileCodeSigningInfo | null> | null
    private iconPath
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    protected doGetCscPassword(): string
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    getIconPath(): Promise<string>
    private getValidIconPath()
    sign(file: string): Promise<void>
    protected doSign(options: SignOptions): Promise<any>
    signAndEditResources(file: string): Promise<void>
    protected postInitApp(appOutDir: string): Promise<void>
  }
}

declare module "electron-builder/out/errorMessages" {
  export const buildIsMissed: string
  export const authorEmailIsMissed: string
  export const buildInAppSpecified: string
  export const nameInBuildSpecified: string
}

declare module "electron-builder/out/targets/dmg" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { MacOptions, DmgOptions } from "electron-builder/out/options/macOptions"
  import { Target, Arch } from "electron-builder-core"

  export class DmgTarget extends Target {
    private packager
    private helperDir
    constructor(packager: PlatformPackager<MacOptions>)
    build(appOutDir: string, arch: Arch): Promise<void>
    computeVolumeName(custom?: string | null): string
    computeDmgOptions(): Promise<DmgOptions>
  }

  export function attachAndExecute(dmgPath: string, readWrite: boolean, task: () => Promise<any>): Promise<void>
}

declare module "electron-builder/out/targets/pkg" {
  import MacPackager from "electron-builder/out/macPackager"
  import { Target, Arch } from "electron-builder-core"

  export class PkgTarget extends Target {
    private packager
    constructor(packager: MacPackager)
    build(appOutDir: string, arch: Arch): Promise<any>
  }

  export function prepareProductBuildArgs(appPath: string, identity: string, keychain: string | n): string[]
}

declare module "electron-builder/out/macPackager" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { MacOptions } from "electron-builder/out/options/macOptions"
  import { CodeSigningInfo } from "electron-builder/out/codeSign"
  import { SignOptions } from "electron-macos-sign"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { Target, Platform, Arch } from "electron-builder-core"
  import { BuildInfo } from "electron-builder/out/packagerApi"

  export default class MacPackager extends PlatformPackager<MacOptions> {
    readonly codeSigningInfo: Promise<CodeSigningInfo>
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    protected prepareAppInfo(appInfo: AppInfo): AppInfo
    getIconPath(): Promise<string | null>
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    pack(outDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): Promise<any>
    private sign(appOutDir, masOptions)
    findInstallerIdentity(isMas: boolean, keychainName: string | n): Promise<string>
    protected doSign(opts: SignOptions): Promise<any>
    protected doFlat(appPath: string, outFile: string, identity: string, keychain: string | n): Promise<any>
  }
}

declare module "electron-builder/out/util/readPackageJson" {
  import { Config } from "electron-builder/out/metadata"

  export function readPackageJson(file: string): Promise<any>

  export function loadConfig(projectDir: string): Promise<Config>

  export function getElectronVersion(config: Config | null | undefined, projectDir: string): Promise<string>
}

declare module "electron-builder/out/yarn" {
  import { Config } from "electron-builder/out/metadata"

  export function installOrRebuild(config: Config, appDir: string, electronVersion: string, platform: string, arch: string, forceInstall?: boolean): Promise<void>

  export function getGypEnv(electronVersion: string, platform: string, arch: string, buildFromSource: boolean): any

  export function rebuild(appDir: string, electronVersion: string, platform: string, arch: string, additionalArgs: Array<string>, buildFromSource: boolean): Promise<void>
}

declare module "electron-builder/out/repositoryInfo" {
  import { Info } from "hosted-git-info"
  import { Metadata } from "electron-builder/out/metadata"

  export interface RepositorySlug {
    user: string
    project: string
  }

  export function getRepositoryInfo(metadata?: Metadata, devMetadata?: Metadata): Promise<Info | null>
}

declare module "electron-builder/out/packager" {
  /// <reference types="node" />
  import { EventEmitter } from "events"
  import { Metadata, Config, AfterPackContext } from "electron-builder/out/metadata"
  import { AppInfo } from "electron-builder/out/appInfo"
  import { TmpDir } from "electron-builder-util/out/tmp"
  import { Platform, Target } from "electron-builder-core"
  import { SourceRepositoryInfo, ArtifactCreated, BuildInfo, PackagerOptions } from "electron-builder/out/packagerApi"

  export class Packager implements BuildInfo {
    options: PackagerOptions
    readonly projectDir: string
    appDir: string
    metadata: Metadata
    private devMetadata
    private _config
    readonly config: Config
    isTwoPackageJsonProjectLayoutUsed: boolean
    electronVersion: string
    readonly eventEmitter: EventEmitter
    appInfo: AppInfo
    readonly tempDirManager: TmpDir
    private _repositoryInfo
    private readonly afterPackHandlers
    readonly repositoryInfo: Promise<SourceRepositoryInfo>
    constructor(options: PackagerOptions)
    addAfterPackHandler(handler: (context: AfterPackContext) => Promise<any> | null): void
    artifactCreated(handler: (event: ArtifactCreated) => void): Packager
    dispatchArtifactCreated(event: ArtifactCreated): void
    build(): Promise<Map<Platform, Map<String, Target>>>
    private doBuild(cleanupTasks)
    private createHelper(platform, cleanupTasks)
    private checkMetadata(appPackageFile, devAppPackageFile)
    private installAppDependencies(platform, arch)
    afterPack(context: AfterPackContext): Promise<void>
  }

  export function normalizePlatforms(rawPlatforms: Array<string | Platform> | string | Platform | n): Array<Platform>

  export function checkWineVersion(checkPromise: Promise<string>): Promise<void>
}

declare module "electron-builder/out/publish/uploader" {
  /// <reference types="node" />
  import { Stats } from "fs-extra-p"
  import { ClientRequest } from "http"

  export function uploadFile(file: string, fileStat: Stats, fileName: string, request: ClientRequest, reject: (error: Error) => void): void
}

declare module "electron-builder/out/publish/publisher" {
  /// <reference types="node" />
  import { ClientRequest } from "http"
  import { BuildInfo } from "electron-builder/out/packagerApi"
  import { PublishConfiguration } from "electron-builder-http/out/publishOptions"
  export type PublishPolicy = "onTag" | "onTagOrDraft" | "always" | "never"

  export interface PublishOptions {
    publish?: PublishPolicy | null
    draft?: boolean
    prerelease?: boolean
  }

  export abstract class Publisher {
    upload(file: string, artifactName?: string): Promise<any>
    uploadData(data: Buffer, fileName: string): Promise<any>
    protected abstract doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<any>
  }

  export function getResolvedPublishConfig(packager: BuildInfo, publishConfig: PublishConfiguration, errorIfCannot: boolean): Promise<PublishConfiguration | null>

  export function getCiTag(): any
}

declare module "electron-builder/out/util/nodeHttpExecutor" {
  /// <reference types="node" />
  import { ClientRequest } from "http"
  import { HttpExecutor, DownloadOptions } from "electron-builder-http"
  import { RequestOptions } from "https"

  export class NodeHttpExecutor extends HttpExecutor<RequestOptions, ClientRequest> {
    private httpsAgentPromise
    download(url: string, destination: string, options?: DownloadOptions | null): Promise<string>
    private addTimeOutHandler(request, callback)
    private doDownload(url, destination, redirectCount, options, agent, callback)
    doApiRequest<T>(options: RequestOptions, token: string | null, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void, redirectCount?: number): Promise<T>
  }
}

declare module "electron-builder/out/publish/gitHubPublisher" {
  /// <reference types="node" />
  import { PublishOptions, Publisher } from "electron-builder/out/publish/publisher"
  import { GithubOptions } from "electron-builder-http/out/publishOptions"
  import { ClientRequest } from "http"

  export interface Release {
    id: number
    tag_name: string
    draft: boolean
    prerelease: boolean
    published_at: string
    upload_url: string
  }

  export class GitHubPublisher extends Publisher {
    private readonly info
    private readonly version
    private readonly options
    private readonly isPublishOptionGuessed
    private tag
    private _releasePromise
    private readonly httpExecutor
    private readonly token
    readonly releasePromise: Promise<Release | null>
    constructor(info: GithubOptions, version: string, options?: PublishOptions, isPublishOptionGuessed?: boolean)
    private getOrCreateRelease()
    protected doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<void>
    private createRelease()
    getRelease(): Promise<any>
    deleteRelease(): Promise<any>
  }
}

declare module "electron-builder/out/publish/BintrayPublisher" {
  /// <reference types="node" />
  import { Publisher, PublishOptions } from "electron-builder/out/publish/publisher"
  import { BintrayOptions } from "electron-builder-http/out/publishOptions"
  import { ClientRequest } from "http"

  export class BintrayPublisher extends Publisher {
    private readonly version
    private readonly options
    private _versionPromise
    private readonly httpExecutor
    private readonly client
    constructor(info: BintrayOptions, version: string, options?: PublishOptions)
    private init()
    protected doUpload(fileName: string, dataLength: number, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): Promise<any>
    deleteRelease(): Promise<any>
  }
}

declare module "electron-builder/out/publish/PublishManager" {
  import { Packager } from "electron-builder/out/packager"
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Publisher, PublishOptions } from "electron-builder/out/publish/publisher"
  import { PublishConfiguration } from "electron-builder-http/out/publishOptions"
  import { BuildInfo } from "electron-builder/out/packagerApi"
  import { PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export class PublishManager {
    private readonly publishOptions
    private readonly nameToPublisher
    readonly publishTasks: Array<Promise<any>>
    private readonly errors
    private isPublishOptionGuessed
    private isPublish
    constructor(packager: Packager, publishOptions: PublishOptions)
    private artifactCreated(event)
    private addTask(promise)
    getOrCreatePublisher(publishConfig: PublishConfiguration, buildInfo: BuildInfo): Publisher | null
    cancelTasks(): void
    awaitTasks(): Promise<void>
  }

  export function getPublishConfigs(packager: PlatformPackager<any>, targetSpecificOptions: PlatformSpecificBuildOptions | null | undefined, errorIfCannot: boolean): Promise<Array<PublishConfiguration>> | null
}

declare module "electron-builder/out/builder" {
  import { PublishOptions } from "electron-builder/out/publish/publisher"
  import { Platform, Arch } from "electron-builder-core"
  import { PackagerOptions } from "electron-builder/out/packagerApi"

  export interface BuildOptions extends PackagerOptions, PublishOptions {
  }

  export interface CliOptions extends PackagerOptions, PublishOptions {
    mac?: Array<string>
    linux?: Array<string>
    win?: Array<string>
    arch?: string
    x64?: boolean
    ia32?: boolean
    armv7l?: boolean
    dir?: boolean
    platform?: string
    project?: string
  }

  export function normalizeOptions(args: CliOptions): BuildOptions

  export function createTargets(platforms: Array<Platform>, type?: string | null, arch?: string | null): Map<Platform, Map<Arch, Array<string>>>

  export function build(rawOptions?: CliOptions): Promise<Array<string>>
}

declare module "electron-builder/out/cli/cliOptions" {
  
  export function createYargs(): any
}

declare module "electron-builder" {
  export { Packager } from "electron-builder/out/packager"
  export { PackagerOptions, ArtifactCreated, BuildInfo, SourceRepositoryInfo } from "electron-builder/out/packagerApi"
  export { getArchSuffix, Platform, Arch, archFromString, Target } from "electron-builder-core"
  export { BuildOptions, build, CliOptions, createTargets } from "electron-builder/out/builder"
  export { PublishOptions, Publisher } from "electron-builder/out/publish/publisher"
  export { Metadata, Config, CompressionLevel } from "electron-builder/out/metadata"
  export { MacOptions, DmgOptions, MasBuildOptions, MacOsTargetName } from "electron-builder/out/options/macOptions"
  export { WinBuildOptions, NsisOptions, SquirrelWindowsOptions, AppXOptions } from "electron-builder/out/options/winOptions"
  export { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  export { DIR_TARGET } from "electron-builder/out/targets/targetFactory"
}

declare module "electron-builder/out/targets/LinuxTargetHelper" {
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  export const installPrefix = "/opt"

  export class LinuxTargetHelper {
    private packager
    readonly icons: Promise<Array<Array<string>>>
    maxIconPath: string | null
    constructor(packager: LinuxPackager)
    private computeDesktopIcons()
    private iconsFromDir(iconsDir)
    private getIcns()
    getDescription(options: LinuxBuildOptions): string
    computeDesktopEntry(platformSpecificBuildOptions: LinuxBuildOptions, exec?: string, destination?: string | null, extra?: {
      [key: string]: string
    }): Promise<string>
    private createFromIcns(tempDir)
    private createMappings(tempDir)
  }
}

declare module "electron-builder/out/targets/fpm" {
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target, Arch } from "electron-builder-core"

  export default class FpmTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    private readonly scriptFiles
    private readonly desktopEntry
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    private createScripts()
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/appImage" {
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target, Arch } from "electron-builder-core"

  export default class AppImageTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    private readonly desktopEntry
    constructor(ignored: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/targets/snap" {
  import { LinuxTargetHelper } from "electron-builder/out/targets/LinuxTargetHelper"
  import { LinuxPackager } from "electron-builder/out/linuxPackager"
  import { Target, Arch } from "electron-builder-core"

  export default class SnapTarget extends Target {
    private packager
    private helper
    private outDir
    private readonly options
    constructor(name: string, packager: LinuxPackager, helper: LinuxTargetHelper, outDir: string)
    build(appOutDir: string, arch: Arch): Promise<any>
  }
}

declare module "electron-builder/out/linuxPackager" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"
  import { Platform, Target } from "electron-builder-core"
  import { LinuxBuildOptions } from "electron-builder/out/options/linuxOptions"
  import { BuildInfo } from "electron-builder/out/packagerApi"

  export class LinuxPackager extends PlatformPackager<LinuxBuildOptions> {
    readonly executableName: string
    constructor(info: BuildInfo)
    readonly defaultTarget: Array<string>
    createTargets(targets: Array<string>, mapper: (name: string, factory: (outDir: string) => Target) => void, cleanupTasks: Array<() => Promise<any>>): void
    readonly platform: Platform
    protected postInitApp(appOutDir: string): Promise<any>
  }
}

declare module "electron-builder/out/packager/mac" {
  import { PlatformPackager } from "electron-builder/out/platformPackager"

  export function createApp(packager: PlatformPackager<any>, appOutDir: string): Promise<void>
}

