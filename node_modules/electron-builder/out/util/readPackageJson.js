"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getElectronVersion = exports.loadConfig = exports.readPackageJson = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

let readPackageJson = exports.readPackageJson = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (file) {
        const data = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(file);
        yield authors(file, data);
        normalizeData(data);
        return data;
    });

    return function readPackageJson(_x) {
        return _ref.apply(this, arguments);
    };
})();

let authors = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (file, data) {
        if (data.contributors != null) {
            return;
        }
        let authorData;
        try {
            authorData = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.resolve(_path.dirname(file), "AUTHORS"), "utf8");
        } catch (ignored) {
            return;
        }
        data.contributors = authorData.split(/\r?\n/g).map(function (it) {
            return it.replace(/^\s*#.*$/, "").trim();
        });
    });

    return function authors(_x2, _x3) {
        return _ref2.apply(this, arguments);
    };
})();

let loadConfig = exports.loadConfig = (() => {
    var _ref3 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (projectDir) {
        try {
            const configPath = _path.join(projectDir, "electron-builder.yml");
            const result = (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(configPath, "utf8")));
            (0, (_log || _load_log()).log)(`Using ${_path.relative(projectDir, configPath)} configuration file`);
            return result;
        } catch (e) {
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        const metadata = yield readPackageJson(_path.join(projectDir, "package.json"));
        if (metadata.directories != null) {
            (0, (_log || _load_log()).warn)(`"directories" in the root is deprecated, please specify in the "build"`);
            if (metadata.build == null) {
                metadata.build = { directories: metadata.directories };
            } else if (metadata.build.directories == null) {
                metadata.build.directories = metadata.directories;
            }
            delete metadata.directories;
        }
        return metadata.build;
    });

    return function loadConfig(_x4) {
        return _ref3.apply(this, arguments);
    };
})();

let getElectronVersion = exports.getElectronVersion = (() => {
    var _ref4 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (config, projectDir) {
        // build is required, but this check is performed later, so, we should check for null
        if (config != null && config.electronVersion != null) {
            return config.electronVersion;
        }
        for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
            try {
                return (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, "node_modules", name, "package.json"))).version;
            } catch (e) {
                if (e.code !== "ENOENT") {
                    (0, (_log || _load_log()).warn)(`Cannot read electron version from ${name} package.json: ${e.message}`);
                }
            }
        }
        const packageJsonPath = _path.join(projectDir, "package.json");
        const electronPrebuiltDep = findFromElectronPrebuilt((yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(packageJsonPath)));
        if (electronPrebuiltDep == null) {
            throw new Error(`Cannot find electron dependency to get electron version in the '${packageJsonPath}'`);
        }
        const firstChar = electronPrebuiltDep[0];
        return firstChar === "^" || firstChar === "~" ? electronPrebuiltDep.substring(1) : electronPrebuiltDep;
    });

    return function getElectronVersion(_x5, _x6) {
        return _ref4.apply(this, arguments);
    };
})();

var _path = _interopRequireWildcard(require("path"));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _log;

function _load_log() {
    return _log = require("electron-builder-util/out/log");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const normalizeData = require("normalize-package-data");

function findFromElectronPrebuilt(packageData) {
    for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
        const devDependencies = packageData.devDependencies;
        let dep = devDependencies == null ? null : devDependencies[name];
        if (dep == null) {
            const dependencies = packageData.dependencies;
            dep = dependencies == null ? null : dependencies[name];
        }
        if (dep != null) {
            return dep;
        }
    }
    return null;
}
//# sourceMappingURL=readPackageJson.js.map