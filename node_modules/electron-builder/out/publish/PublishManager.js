"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PublishManager = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

let getPublishConfigsForUpdateInfo = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (packager, publishConfigs) {
        if (publishConfigs === null) {
            return null;
        }
        if (publishConfigs.length === 0) {
            // https://github.com/electron-userland/electron-builder/issues/925#issuecomment-261732378
            // default publish config is github, file should be generated regardless of publish state (user can test installer locally or manage the release process manually)
            const repositoryInfo = yield packager.info.repositoryInfo;
            if (repositoryInfo != null && repositoryInfo.type === "github") {
                const resolvedPublishConfig = yield (0, (_publisher || _load_publisher()).getResolvedPublishConfig)(packager.info, { provider: repositoryInfo.type }, false);
                if (resolvedPublishConfig != null) {
                    return [resolvedPublishConfig];
                }
            }
        }
        return publishConfigs;
    });

    return function getPublishConfigsForUpdateInfo(_x2, _x3) {
        return _ref2.apply(this, arguments);
    };
})();

let writeUpdateInfo = (() => {
    var _ref3 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (event, _publishConfigs) {
        const packager = event.packager;
        const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, _publishConfigs);
        if (publishConfigs == null || publishConfigs.length === 0) {
            return;
        }
        const outDir = event.target.outDir;
        for (const publishConfig of publishConfigs) {
            const isGitHub = publishConfig.provider === "github";
            if (!(publishConfig.provider === "generic" || isGitHub)) {
                continue;
            }
            const version = packager.appInfo.version;
            const channel = publishConfig.channel || "latest";
            if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC) {
                const updateInfoFile = isGitHub ? _path.join(outDir, "github", `${channel}-mac.json`) : _path.join(outDir, `${channel}-mac.json`);
                yield (0, (_fsExtraP || _load_fsExtraP()).outputJson)(updateInfoFile, {
                    version: version,
                    url: computeDownloadUrl(publishConfig, packager.generateName2("zip", "mac", isGitHub), version)
                }, { spaces: 2 });
                packager.info.dispatchArtifactCreated({
                    file: updateInfoFile,
                    packager: packager,
                    target: null,
                    publishConfig: publishConfig
                });
            } else {
                const githubArtifactName = `${packager.appInfo.name}-Setup-${version}.exe`;
                const sha2 = yield sha256(event.file);
                const updateInfoFile = _path.join(outDir, `${channel}.yml`);
                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(updateInfoFile, (0, (_jsYaml || _load_jsYaml()).safeDump)({
                    version: version,
                    githubArtifactName: githubArtifactName,
                    path: _path.basename(event.file),
                    sha2: sha2
                }));
                const githubPublishConfig = publishConfigs.find(function (it) {
                    return it.provider === "github";
                });
                if (githubPublishConfig != null) {
                    // to preserve compatibility with old electron-updater (< 0.10.0), we upload file with path specific for GitHub
                    packager.info.dispatchArtifactCreated({
                        data: new Buffer((0, (_jsYaml || _load_jsYaml()).safeDump)({
                            version: version,
                            path: githubArtifactName,
                            sha2: sha2
                        })),
                        artifactName: `${channel}.yml`,
                        packager: packager,
                        target: null,
                        publishConfig: githubPublishConfig
                    });
                }
                const genericPublishConfig = publishConfigs.find(function (it) {
                    return it.provider === "generic";
                });
                if (genericPublishConfig != null) {
                    packager.info.dispatchArtifactCreated({
                        file: updateInfoFile,
                        packager: packager,
                        target: null,
                        publishConfig: genericPublishConfig
                    });
                }
                break;
            }
        }
    });

    return function writeUpdateInfo(_x4, _x5) {
        return _ref3.apply(this, arguments);
    };
})();

exports.getPublishConfigs = getPublishConfigs;

var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _publisher;

function _load_publisher() {
    return _publisher = require("./publisher");
}

var _gitHubPublisher;

function _load_gitHubPublisher() {
    return _gitHubPublisher = require("./gitHubPublisher");
}

var _log;

function _load_log() {
    return _log = require("electron-builder-util/out/log");
}

var _BintrayPublisher;

function _load_BintrayPublisher() {
    return _BintrayPublisher = require("./BintrayPublisher");
}

var _electronBuilderCore;

function _load_electronBuilderCore() {
    return _electronBuilderCore = require("electron-builder-core");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _promise;

function _load_promise() {
    return _promise = require("electron-builder-util/out/promise");
}

var _isCi;

function _load_isCi() {
    return _isCi = _interopRequireDefault(require("is-ci"));
}

var _url;

function _load_url() {
    return _url = _interopRequireWildcard(require("url"));
}

var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PublishManager {
    constructor(packager, publishOptions) {
        this.publishOptions = publishOptions;
        this.nameToPublisher = new Map();
        this.publishTasks = [];
        this.errors = [];
        this.isPublishOptionGuessed = false;
        this.isPublish = false;
        if (publishOptions.publish === undefined) {
            if (process.env.npm_lifecycle_event === "release") {
                publishOptions.publish = "always";
            } else if (isAuthTokenSet()) {
                const tag = (0, (_publisher || _load_publisher()).getCiTag)();
                if (tag != null) {
                    (0, (_log || _load_log()).log)(`Tag ${tag} is defined, so artifacts will be published`);
                    publishOptions.publish = "onTag";
                    this.isPublishOptionGuessed = true;
                } else if ((_isCi || _load_isCi()).default) {
                    (0, (_log || _load_log()).log)("CI detected, so artifacts will be published if draft release exists");
                    publishOptions.publish = "onTagOrDraft";
                    this.isPublishOptionGuessed = true;
                }
            }
        }
        if (publishOptions.publish != null && publishOptions.publish !== "never") {
            this.isPublish = publishOptions.publish !== "onTag" || (0, (_publisher || _load_publisher()).getCiTag)() != null;
            if (this.isPublish && !isAuthTokenSet()) {
                throw new Error(`Publish is set to ${publishOptions.publish}, but neither GH_TOKEN nor BT_TOKEN is not set`);
            }
        }
        packager.addAfterPackHandler((() => {
            var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (event) {
                if (!(event.electronPlatformName == "darwin" || event.packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS)) {
                    return;
                }
                const packager = event.packager;
                const publishConfigs = yield getPublishConfigsForUpdateInfo(packager, (yield getPublishConfigs(packager, null, false)));
                if (publishConfigs == null || publishConfigs.length === 0) {
                    return;
                }
                yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(_path.join(packager.getResourcesDir(event.appOutDir), "app-update.yml"), (0, (_jsYaml || _load_jsYaml()).safeDump)(publishConfigs[0]));
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
        packager.artifactCreated(event => this.addTask(this.artifactCreated(event)));
    }
    artifactCreated(event) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const packager = event.packager;
            const target = event.target;
            const publishConfigs = event.publishConfig == null ? yield getPublishConfigs(packager, target == null ? null : packager.config[target.name], !_this.isPublishOptionGuessed) : [event.publishConfig];
            if (publishConfigs == null) {
                if (_this.isPublish) {
                    (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`${event.file} is not published: no publish configs`);
                }
                return;
            }
            if (_this.isPublish) {
                for (const publishConfig of publishConfigs) {
                    const publisher = _this.getOrCreatePublisher(publishConfig, packager.info);
                    if (publisher != null) {
                        if (event.file == null) {
                            _this.addTask(publisher.uploadData(event.data, event.artifactName));
                        } else {
                            _this.addTask(publisher.upload(event.file, event.artifactName));
                        }
                    }
                }
            }
            if (target != null && event.file != null) {
                if (packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.MAC && target.name === "zip" || packager.platform === (_electronBuilderCore || _load_electronBuilderCore()).Platform.WINDOWS && target.name === "nsis") {
                    _this.addTask(writeUpdateInfo(event, publishConfigs));
                }
            }
        })();
    }
    addTask(promise) {
        this.publishTasks.push(promise.catch(it => this.errors.push(it)));
    }
    getOrCreatePublisher(publishConfig, buildInfo) {
        let publisher = this.nameToPublisher.get(publishConfig.provider);
        if (publisher == null) {
            publisher = createPublisher(buildInfo, publishConfig, this.publishOptions, this.isPublishOptionGuessed);
            this.nameToPublisher.set(publishConfig.provider, publisher);
        }
        return publisher;
    }
    cancelTasks() {
        for (const task of this.publishTasks) {
            if ("cancel" in task) {
                task.cancel();
            }
        }
    }
    awaitTasks() {
        var _this2 = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            if (_this2.errors.length > 0) {
                _this2.cancelTasks();
                (0, (_promise || _load_promise()).throwError)(_this2.errors);
                return;
            }
            const publishTasks = _this2.publishTasks;
            let list = publishTasks.slice();
            publishTasks.length = 0;
            while (list.length > 0) {
                yield (_bluebirdLstC2 || _load_bluebirdLstC2()).default.all(list);
                if (publishTasks.length === 0) {
                    break;
                } else {
                    list = publishTasks.slice();
                    publishTasks.length = 0;
                }
            }
        })();
    }
}
exports.PublishManager = PublishManager;

function createPublisher(buildInfo, publishConfig, options) {
    let isPublishOptionGuessed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    const version = buildInfo.metadata.version;
    if (publishConfig.provider === "github") {
        const githubInfo = publishConfig;
        (0, (_log || _load_log()).log)(`Creating Github Publisher — owner: ${githubInfo.owner}, project: ${githubInfo.repo}, version: ${version}`);
        return new (_gitHubPublisher || _load_gitHubPublisher()).GitHubPublisher(githubInfo, version, options, isPublishOptionGuessed);
    }
    if (publishConfig.provider === "bintray") {
        const bintrayInfo = publishConfig;
        (0, (_log || _load_log()).log)(`Creating Bintray Publisher — user: ${bintrayInfo.user || bintrayInfo.owner}, owner: ${bintrayInfo.owner},  package: ${bintrayInfo.package}, repository: ${bintrayInfo.repo}, version: ${version}`);
        return new (_BintrayPublisher || _load_BintrayPublisher()).BintrayPublisher(bintrayInfo, version, options);
    }
    return null;
}
function isAuthTokenSet() {
    return !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.GH_TOKEN) || !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.BT_TOKEN);
}
function computeDownloadUrl(publishConfig, fileName, version) {
    if (publishConfig.provider === "generic") {
        const baseUrl = (_url || _load_url()).parse(publishConfig.url);
        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || "/", fileName) }));
    } else {
        const gh = publishConfig;
        return `https://github.com${`/${gh.owner}/${gh.repo}/releases`}/download/v${version}/${fileName}`;
    }
}
function getPublishConfigs(packager, targetSpecificOptions, errorIfCannot) {
    let publishers;
    // check build.nsis (target)
    if (targetSpecificOptions != null) {
        publishers = targetSpecificOptions.publish;
        // if explicitly set to null - do not publish
        if (publishers === null) {
            return null;
        }
    }
    // check build.win (platform)
    if (publishers == null) {
        publishers = packager.platformSpecificBuildOptions.publish;
        if (publishers === null) {
            return null;
        }
    }
    if (publishers == null) {
        publishers = packager.config.publish;
        if (publishers === null) {
            return null;
        }
        if (publishers == null && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.GH_TOKEN)) {
            publishers = [{ provider: "github" }];
        }
        // if both tokens are set — still publish to github (because default publisher is github)
        if (publishers == null && !(0, (_electronBuilderUtil || _load_electronBuilderUtil()).isEmptyOrSpaces)(process.env.BT_TOKEN)) {
            publishers = [{ provider: "bintray" }];
        }
    }
    return (_bluebirdLstC2 || _load_bluebirdLstC2()).default.map((0, (_electronBuilderUtil || _load_electronBuilderUtil()).asArray)(publishers), it => (0, (_publisher || _load_publisher()).getResolvedPublishConfig)(packager.info, typeof it === "string" ? { provider: it } : it, errorIfCannot));
}
function sha256(file) {
    return new (_bluebirdLstC2 || _load_bluebirdLstC2()).default((resolve, reject) => {
        const hash = (0, (_crypto || _load_crypto()).createHash)("sha256");
        hash.on("error", reject).setEncoding("hex");
        (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(file).on("error", reject).on("end", () => {
            hash.end();
            resolve(hash.read());
        }).pipe(hash, { end: false });
    });
}
//# sourceMappingURL=PublishManager.js.map